generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String          @id @default(uuid())
  email          String          @unique @db.VarChar(100)
  userName       String          @unique @db.VarChar(255)
  dateJoined     DateTime        @default(now())
  lastEdited     DateTime        @default(now())
  password       String          @db.VarChar(255)
  refreshToken   String?         @db.VarChar(255)
  followedBy     Follow[]        @relation("followedBy")
  following      Follow[]        @relation("following")
  recipe         Recipe[]
  recipeEditedBy Recipe[]        @relation("recipeEditedById")
  blockedUser    BlockedUser[]   @relation("blocked")
  blockingUser   BlockedUser[]   @relation("blocking")
  buildCreatedBy Build[]         @relation("buildCreatedBy")
  buildEditedBy  Build[]         @relation("buildEditedBy")
  archivedBuild  ArchivedBuild[]
  buildUser      BuildUser[]
}

model Follow {
  followedBy   User   @relation("followedBy", fields: [followedById], references: [id])
  followedById String
  following    User   @relation("following", fields: [followingId], references: [id])
  followingId  String
  relationship String

  @@id([followingId, followedById])
}

model BlockedUser {
  user           User   @relation("blocked", fields: [userId], references: [id])
  userId         String
  blockingUser   User   @relation("blocking", fields: [blockingUserId], references: [id])
  blockingUserId String

  @@id([userId, blockingUserId])
}

model Recipe {
  id          String   @id @default(uuid())
  createdAt   DateTime @default(now())
  editedAt    DateTime @default(now())
  name        String   @unique @db.VarChar(255)
  about       String?
  createdBy   User?    @relation(fields: [createdById], references: [id])
  createdById String?
  editedBy    User?    @relation("recipeEditedById", fields: [editedById], references: [id])
  editedById  String?
  build       Build[]
}

model Build {
  id            String          @id @default(uuid())
  buildName     String
  createdAt     DateTime        @default(now())
  createdById   String
  createdBy     User            @relation("buildCreatedBy", fields: [createdById], references: [id])
  editedAt      DateTime        @default(now())
  editedById    String
  editedBy      User            @relation("buildEditedBy", fields: [editedById], references: [id])
  instructions  String
  notes         String?
  glassware     String          @db.VarChar()
  ice           String          @db.VarChar(100)
  touch         Touch[]
  archivedBuild ArchivedBuild[]
  buildUser     BuildUser[]
  version       Int
  recipe        Recipe?         @relation(fields: [recipeName], references: [name])
  recipeName    String
}

model ArchivedBuild {
  id            String          @id @default(uuid())
  buildName     String          @default("")
  createdAt     DateTime        @default(now())
  createdById   String?
  createdBy     User?           @relation(fields: [createdById], references: [id])
  build         Build           @relation(fields: [buildId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  buildId       String
  instructions  String?
  notes         String?
  glassware     String?         @db.VarChar()
  ice           String?         @db.VarChar(100)
  version       Int
  archivedTouch ArchivedTouch[]
}

model BuildUser {
  userId     String
  buildId    String
  user       User?  @relation(fields: [userId], references: [id], onDelete: Cascade)
  build      Build? @relation(fields: [buildId], references: [id], onDelete: Cascade)
  permission String

  @@id([userId, buildId])
}

model Touch {
  id             String     @id @default(uuid())
  build          Build      @relation(fields: [buildId], references: [id], onDelete: Cascade)
  buildId        String
  order          Int
  amount         Float      @db.Real
  unit           String     @db.VarChar(50)
  ingredientName String
  ingredient     Ingredient @relation(fields: [ingredientName], references: [name], onDelete: NoAction, onUpdate: NoAction)
  version        Int        @default(0)
}

model ArchivedTouch {
  id              String        @id @default(uuid())
  archivedBuild   ArchivedBuild @relation(fields: [archivedBuildId], references: [id], onDelete: Cascade)
  archivedBuildId String
  order           Int?
  amount          Float         @db.Real
  unit            String        @db.VarChar(50)
  ingredientName  String
  ingredient      Ingredient?   @relation(fields: [ingredientName], references: [name], onDelete: NoAction, onUpdate: NoAction)
  version         Int
}

model Ingredient {
  id            String               @id @default(uuid())
  name          String               @unique @db.VarChar(255)
  description   String?
  touch         Touch[]
  parents       IngredientRelation[] @relation("IngredientParent")
  children      IngredientRelation[] @relation("IngredientChild")
  archivedTouch ArchivedTouch[]
}

// Intermediate join table for the many-to-many relationship
model IngredientRelation {
  parent   Ingredient @relation("IngredientParent", fields: [parentId], references: [id])
  parentId String
  child    Ingredient @relation("IngredientChild", fields: [childId], references: [id])
  childId  String

  @@id([parentId, childId])
}
